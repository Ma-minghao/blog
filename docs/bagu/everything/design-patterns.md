# 设计模式

> [设计模式](https://kiraraty.github.io/fe-doc/#/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
>
> [23 种设计模式详解（全23种）](https://blog.csdn.net/A1342772/article/details/91349142)

## 软件设计七大原则(OOP原则)

开闭原则：对扩展开放，对修改关闭。
里氏替换原则：不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义。
依赖倒置原则：要面向接口编程，不要面向实现编程。
单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。
接口隔离原则：要为各个类建立它们需要的专用接口。
迪米特法则：一个类应该保持对其它对象最少的了解，降低耦合度。
合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

## 创建型-单例模式

保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

**应用：**

- 网页中的全局状态管理器。
- 数据库连接池的管理。
- 日志记录器

## 创建型-工厂模式

### 简单工厂模式

定义了一个创建对象的类，由这个类来封装实例化对象的行为。

```js
class SimpleBarFactory {
  static create(type) {
    switch (type) {
      case 'A':
        return new BarA()
      case 'B':
        return new BarA()
    }
  }
}
```

## 结构型-装饰器模式

在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求。在对象功能扩展方面，它比继承更有弹性。

## 结构型-适配器模式

适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。例如：axios 抹平了浏览器与 Node.js 之间的接口差异。

## 结构型-代理模式

出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的。

**应用：**

- 对对象的访问进行控制和管理。
- 在访问对象时添加额外的逻辑，例如缓存、安全性检查等。

## 行为型-策略模式

根据不同参数可以命中不同的策略

避免使用多重条件判断。扩展性良好。

## 行为型-观察者模式

观察者模式定义了一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

与`发布-订阅模式`的区别是，没有事件中心

## 行为型-迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
