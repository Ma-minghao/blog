# 内存管理

## 虚拟内存

操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

通过内存分段和内存分页，管理虚拟地址与物理地址之间的关系

内存分段的问题：内存碎片、内存交换的效率低

对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 Swap 内存区域，需要用到 Swap 内存（硬盘空间），这个过程会产生性能瓶颈。

分页是把整个虚拟和物理内存空间切成一段段固定尺寸（页）的大小（4K），每个进程都是有自己的页表

![](https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png)

内存分页在内存不够时将「最近没被使用」的内存页面放到 Swap 区域，用到时再读进来

虚拟内存的作用:

1. 虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
2. 由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
3. 页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

## Linux 的虚拟地址空间

![](https://cdn.xiaolincoding.com//mysql/other/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png)

## 内存分配过程

程序申请的内存是虚拟内存

当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。

如果有空闲的物理内存就直接分配，没有就回收内存，内存回收的方式为：后台内存回收（kswapd）和直接内存回收（direct reclaim）。如果内存回收后仍然不够分配的就触发 OOM （Out of Memory）机制，递归杀掉占用物理内存较高的进程。
