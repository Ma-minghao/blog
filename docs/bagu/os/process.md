# 进程管理

## 进程与线程的区别

- 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
- 进程包含线程，一个进程可以有多个线程，多个线程之间共享进程的资源，可以并发执行
- 进程之间切换开销较大，线程之间切换开销小

## 进程间通信（IPC）

- 管道：`|` 将两个命令连接起来，可以使用 `mkfifo` 创建命名管道
- 消息队列：保存在内核中的消息链表，设计到系统调用，消息队列保存在一个文件中。[System V 规范的消息队列](https://www.testerfans.com/archives/linux-ipc-message-queue)
- 共享内存：共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。需要锁保证数据的一致性，比如信号量。信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，为了防止多进程竞争共享资源，而造成的数据错乱
- Channel：半双工通信，数据从一个进程传递到另一个进程
- 信号：比如 `SIGINT` 信号
- Socket：网络通信

## 死锁

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.png)

产生死锁的四个必要条件是：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件

避免死锁的方法：

- 所有的线程都按顺序访问资源

## 各种锁

- 互斥锁加锁失败后，线程会释放 CPU ，给其他线程
- 自旋锁加锁失败后，线程会忙等待，直到它拿到锁
- 悲观锁：认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁。用于“读多写少“的环境，避免频繁加锁影响性能
- 乐观锁：总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。用于”写多读少“的环境，避免频繁失败和重试影响性能，可以有效避免死锁
