# 操作系统结构

现代操作系统，内核一般会提供 4 个基本能力：

- 管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；
- 管理内存，决定内存的分配和回收，也就是内存管理的能力；
- 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；
- 提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。

系统调用的过程：

![系统调用的过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/systemcall.png)

## Linux

- 多任务（MultiTask）：Linux 是一个多任务的操作系统，任务可以并行或并发执行
- 对称多处理（SMP）：每个 CPU 的地位是相等的，都可以访问完整的内存和硬件资源
- 可执行文件链接格式（ELF）
- 宏内核（Monolithic Kernel）：宏内核的特征是系统内核的所有模块都运行在内核态。相反微内核架构的内核只保留最基本的能力，对于不在内核态的程序需要频繁切换到内核态

## 预读失败与缓存污染

传统的 LRU 算法存在这两个问题预读失败与缓存污染

预读失败：比如程序读取磁盘0-3KB，出于空间局部性原理实际读取 0-16KB 的数据放到 LRU 链表里

Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list），预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。

缓存污染：在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」，将真正活跃的数据淘汰掉了

解决办法是提高进入活跃 LRU 链表的门槛，比如内存页被访问第二次的时候才进入活跃链表
